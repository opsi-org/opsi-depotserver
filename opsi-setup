#! /usr/bin/env python
#
# Copyright (C) 2011-2017 uib GmbH - http://www.uib.de
# All rights reserved.
#

import codecs
import getopt
import grp
import json
import os
import pwd
import re
import shutil
import socket
import sys
import time

import OPSI.System.Posix as Posix
import OPSI.Util.Task.ConfigureBackend as backendUtils
from OPSI.Backend.Backend import ExtendedConfigDataBackend
from OPSI.Backend.File import FileBackend
from OPSI.Backend.JSONRPC import JSONRPCBackend
from OPSI.Logger import LOG_DEBUG, LOG_NONE, LOG_INFO, LOG_NOTICE, Logger
from OPSI.Object import (ConfigState, HostGroup, LocalbootProduct,
	NetbootProduct, ObjectToGroup, OpsiClient,
	OpsiConfigserver, OpsiDepotserver, ProductDependency, ProductOnClient,
	ProductOnDepot, ProductPropertyState, UnicodeConfig, UnicodeProductProperty)
from OPSI.System.Posix import (execute, getEthernetDevices,
	getNetworkDeviceConfig, which)
from OPSI.Types import (forceActionRequest, forceBool, forceFilename,
	forceGroupId, forceHostId, forceInstallationStatus, forceInt,
	forceIpAddress, forceList, forceObjectId, forceProductId,
	forceUnicodeList)
from OPSI.UI import UIFactory
from OPSI.Util import blowfishDecrypt, getfqdn, randomString
from OPSI.Util.File import IniFile
from OPSI.Util.File.Opsi import (BackendDispatchConfigFile, HostKeyFile,
	PackageControlFile)
from OPSI.Util.Task.Certificate import (DEFAULT_CERTIFICATE_PARAMETERS,
	OPSICONFD_CERTFILE, NoCertificateError, UnreadableCertificateError,
	createCertificate, loadConfigurationFromCertificate, renewCertificate)
from OPSI.Util.Task.CleanupBackend import cleanupBackend
from OPSI.Util.Task.ConfigureBackend.ConfigurationData import initializeConfigs
from OPSI.Util.Task.ConfigureBackend.DHCPD import configureDHCPD
from OPSI.Util.Task.ConfigureBackend.MySQL import (
	DatabaseConnectionFailedException,
	configureMySQLBackend as configureMySQLBackendWithoutGUI
)
from OPSI.Util.Task.Rights import setRights
from OPSI.Util.Task.Sudoers import patchSudoersFileForOpsi
from OPSI.Util.Task.UpdateBackend.MySQL import updateMySQLBackend
from OPSI.Util.Task.Samba import configureSamba


logger = Logger()

logger.setConsoleLevel(LOG_NOTICE)
logger.setConsoleColor(True)

LOG_FILE = u'/tmp/opsi-setup.log'
SMB_CONF = u'/etc/samba/smb.conf'
DHCPD_CONF = Posix.locateDHCPDConfig(u'/etc/dhcp3/dhcpd.conf')

OPSICONFD_USER = u'opsiconfd'
ADMIN_GROUP = u'opsiadmin'
CLIENT_USER = u'pcpatch'

OPSI_GLOBAL_CONF = u'/etc/opsi/global.conf'

sysConfig = {}
ipAddress = None


def getDistribution():
	distribution = ''
	try:
		f = os.popen('lsb_release -d 2>/dev/null')
		distribution = f.read().split(':')[1].strip()
		f.close()
	except:
		pass
	return distribution


# TODO: use OPSI.System.Posix.Sysconfig for a more standardized approach
def getSysConfig():
	global sysConfig
	if sysConfig:
		return sysConfig

	logger.notice(u"Getting current system config")

	distri = Distribution()
	sysConfig['distributor'] = distri.distributor
	sysConfig['distribution'] = getDistribution()

	if not sysConfig['distributor'] or not sysConfig['distribution']:
		logger.warning(u"Failed to get distributor/distribution")

	sysConfig.update(getNetworkConfiguration(ipAddress))

	sysConfig['fqdn'] = getLocalFqdn()
	sysConfig['hostname'] = sysConfig['fqdn'].split(u'.')[0]
	sysConfig['domain'] = u'.'.join(sysConfig['fqdn'].split(u'.')[1:])
	sysConfig['winDomain'] = readWindowsDomainFromSambaConfig(SMB_CONF)

	logger.notice(u"System information:")
	logger.notice(u"   distributor  : %s" % sysConfig['distributor'])
	logger.notice(u"   distribution : %s" % sysConfig['distribution'])
	logger.notice(u"   ip address   : %s" % sysConfig['ipAddress'])
	logger.notice(u"   netmask      : %s" % sysConfig['netmask'])
	logger.notice(u"   subnet       : %s" % sysConfig['subnet'])
	logger.notice(u"   broadcast    : %s" % sysConfig['broadcast'])
	logger.notice(u"   fqdn         : %s" % sysConfig['fqdn'])
	logger.notice(u"   hostname     : %s" % sysConfig['hostname'])
	logger.notice(u"   domain       : %s" % sysConfig['domain'])
	logger.notice(u"   win domain   : %s" % sysConfig['winDomain'])

	return sysConfig


def configureClientUser():
	logger.notice(u"Configuring client user %s" % CLIENT_USER)

	clientUserHome = pwd.getpwnam(CLIENT_USER)[5]
	sshDir = os.path.join(clientUserHome, '.ssh')

	if os.path.exists(sshDir):
		shutil.rmtree(sshDir)

	idRsa = os.path.join(sshDir, u'id_rsa')
	idRsaPub = os.path.join(sshDir, u'id_rsa.pub')
	authorizedKeys = os.path.join(sshDir, u'authorized_keys')
	if not os.path.exists(sshDir):
		os.mkdir(sshDir)
	if not os.path.exists(idRsa):
		logger.notice(u"   Creating RSA private key for user %s in '%s'" % (CLIENT_USER, idRsa))
		execute(u"%s -N '' -t rsa -f %s" % (which('ssh-keygen'), idRsa))

	if not os.path.exists(authorizedKeys):
		with codecs.open(idRsaPub, 'r', 'utf-8') as f:
			with codecs.open(authorizedKeys, 'w', 'utf-8') as f2:
				f2.write(f.read())

	setRights(sshDir)

	password = None
	backend = None
	from OPSI.Backend.BackendManager import BackendManager

	try:
		backend = BackendManager(
			dispatchConfigFile=u'/etc/opsi/backendManager/dispatch.conf',
			backendConfigDir=u'/etc/opsi/backends',
			extensionConfigDir=u'/etc/opsi/backendManager/extend.d',
			depotBackend=True
		)
		depot = backend.host_getObjects(type='OpsiDepotserver', id=getSysConfig()['fqdn'])[0]

		configserverId = None
		for configserver in backend.host_getObjects(type='OpsiConfigserver'):
			if configserver.id == getSysConfig()['fqdn']:
				configserverId = None
				break
			else:
				configserverId = configserver.id

		if configserverId:
			try:
				jsonrpcBackend = JSONRPCBackend(address=configserverId, username=depot.id, password=depot.opsiHostKey)
				password = blowfishDecrypt(depot.opsiHostKey, jsonrpcBackend.user_getCredentials(username=u'pcpatch', hostId=depot.id)['password'])
				jsonrpcBackend.backend_exit()
			except Exception as e:
				logger.info(u"Failed to get client user (pcpatch) password from configserver: %s" % e)

		if not password:
			password = blowfishDecrypt(depot.opsiHostKey, backend.user_getCredentials(username=u'pcpatch', hostId=depot.id)['password'])
	except Exception as e:
		logger.info(u"Failed to get client user (pcpatch) password: %s" % e)
		password = randomString(12)
	finally:
		if backend is not None:
			backend.backend_exit()

	if not password:
		logger.warning("No password for pcpatch found. Generating random password.")
		password = randomString(12)

	logger.addConfidentialString(password)
	execute('opsi-admin -d task setPcpatchPassword "%s"' % password)


def update(fromVersion=None):
	# 3.x => 4.x
	if os.path.exists(u'/var/lib/opsi/products'):
		logger.notice(u"Found /var/lib/opsi/products, moving to /var/lib/opsi/repository")
		if not os.path.exists(u'/var/lib/opsi/repository'):
			os.mkdir(u'/var/lib/opsi/repository')
		for f in os.listdir(u'/var/lib/opsi/products'):
			shutil.move(os.path.join(u'/var/lib/opsi/products', f), os.path.join(u'/var/lib/opsi/repository', f))
		try:
			os.rmdir(u'/var/lib/opsi/products')
		except Exception as e:
			logger.warning(e)

	isConfigServer = False
	try:
		bdc = BackendDispatchConfigFile(u'/etc/opsi/backendManager/dispatch.conf')
		dispatchConfig = bdc.parse()
		for entry in dispatchConfig:
			(regex, backends) = entry
			if not re.search(regex, 'backend_createBase'):
				continue
			if 'jsonrpc' not in backends:
				isConfigServer = True
			break
	except Exception as e:
		logger.warning(e)

	if isConfigServer:
		from OPSI.Backend.BackendManager import BackendManager

		try:
			backend = BackendManager(
				dispatchConfigFile=u'/etc/opsi/backendManager/dispatch.conf',
				backendConfigDir=u'/etc/opsi/backends',
				extensionConfigDir=u'/etc/opsi/backendManager/extend.d',
				depotbackend=False
			)
			backend.backend_createBase()
			backend.backend_exit()
		except Exception as e:
			logger.warning(e)

	# 4.0 => 4.0.1
	"""
	link = '/var/lib/opsi/depot'
	source = '/opt/pcbin/install'
	if not os.path.exists(link) and os.path.exists(source):
		try:
			os.symlink(source, link)
		except Exception, e:
			logger.warning(u"Failed to create symlink '%s' pointing to '%s': %s" % (link, source, e))
	"""

	# 4.0.3 => 4.0.4
	depotDir = '/var/lib/opsi/depot'
	if not os.path.exists(depotDir):
		try:
			os.mkdir(depotDir)
			if os.path.exists("/opt/pcbin/install"):
				logger.warning(u"You have an old depot configuration. Using /opt/pcbin/install is depracted, please youse /var/lib/opsi/depot instead.")
		except Exception as e:
			logger.warning(u"Failed to create depot directory '%s': %s" % (depotDir, e))


	if isConfigServer:
		initializeConfigs()
	configureSamba()


def updateFileBackend():
	backendConfigFile = u'/etc/opsi/backends/file.conf'

	if not os.path.isfile(backendConfigFile):
		raise Exception("Configuration file does not exist: '%s'" % (backendConfigFile))

	logger.notice(u"Loading backend config '%s'" % backendConfigFile)
	l = {'socket': socket, 'os': os, 'sys': sys, 'module': '', 'config': {}}
	execfile(backendConfigFile, l)
	config = l['config']
	config.update(backendConfig)
	logger.info(u"Current file backend config: %s" % config)

	#test for version 40
	newConfigFile = os.path.join(os.path.dirname(config["baseDir"]), u'config', u'config.ini')
	if os.path.isfile(newConfigFile):
		raise Exception(u"Detected a file ('%s') that should only be in opsi version 4.0, update denied!" % (newConfigFile))

	logger.notice(u"Creating file backend instance")
	backend = ExtendedConfigDataBackend(FileBackend(**config))

	backupDir = os.path.join(os.path.dirname(config["baseDir"]), u'backup_%s' % time.time())

	backupClientConfigDir   = os.path.join(backupDir, u'clients')
	backupDepotConfigDir    = os.path.join(backupDir, u'depots')
#	backupProductDir        = os.path.join(backupDir, u'products')
#	backupAuditDir          = os.path.join(backupDir, u'audit')
#	backupClientTemplateDir = os.path.join(backupDir, u'templates')

	logger.notice(u"Backing up current directory '%s' to '%s'" % (config["baseDir"], backupDir))
	if not os.path.isdir(config["baseDir"]):
		raise Exception("Base directory given from file '%s' does not exist: '%s'" % (backendConfigFile, config["baseDir"]))

	noClientDir = False
	if not os.path.isdir(os.path.join(config["baseDir"], u'clients')):
		noClientDir = True
		logger.warning("Client directory does not exist: '%s'" % (os.path.join(config["baseDir"], u'clients')))

	noDepotDir = False
	if not os.path.isdir(os.path.join(config["baseDir"], u'depots')):
		noDepotDir = True
		logger.warning("Depot directory does not exist: '%s'" % (os.path.join(config["baseDir"], u'depots')))

	shutil.move(config["baseDir"], backupDir)

	backend.backend_createBase()

	opsiHostKeys = {}
	if os.path.isfile(config["hostKeyFile"]):
		logger.notice(u"Backing up hostKeyFile '%s' to '%s'" % (config["hostKeyFile"], backupDir))
		shutil.copy(config["hostKeyFile"], backupDir)
		lines = []
		f = codecs.open(config["hostKeyFile"], 'r', 'utf-8')
		for line in f.readlines():
			line = line.strip()
			if not line:
				continue
			if line[0] in ('#', ';'):
				continue
			try:
				(hostId, key) = line.strip().split(':')
				hostId = forceHostId(hostId.replace('_', '-'))
			except Exception as e:
				logger.error(u"Bad line in %s: '%s': %s" % (config["hostKeyFile"], line, e))
				continue
			lines.append(u"%s:%s\n" % (hostId, key))
		f.close()
		f = codecs.open(config["hostKeyFile"], 'w', 'utf-8')
		f.writelines(lines)
		f.close()
		opsiHostKeys = HostKeyFile(filename = config["hostKeyFile"]).parse()
		os.remove(config["hostKeyFile"])
	else:
		logger.warning(u"Host key file does not exist: '%s'" % (config["hostKeyFile"]))

	lockedList = {}
	if os.path.isfile(os.path.join(backupDepotConfigDir, u'product.locks')):
		logger.info(u"Getting information on product.locks" % ())
		try:
			iniFile = IniFile(filename=os.path.join(backupDepotConfigDir, u'product.locks'), ignoreCase=False)
			ini = iniFile.parse()

			for proId in ini.sections():
				for depId in ini.options(proId):
					if (ini.get(proId, depId) == u'locked'):
						key = u'%s' % (proId.lower() + '#' + depId.lower())
						lockedList[key] = True
		except Exception as e:
			logger.error(u"Could not get all information on product.locks: %s" % (e))
	else:
		logger.warning(u"Product locks fils does not exist: '%s'" % (os.path.join(backupDepotConfigDir, u'product.locks')))

	#needed for configStates
	updatedConfigs = []

	logger.notice(u"Updating depots ...")
	if not noDepotDir:
		for depotId in os.listdir(backupDepotConfigDir):
			oldPath = os.path.join(backupDepotConfigDir, depotId)
			oldDepot = os.path.join(oldPath, u'depot.ini')
			if (not oldDepot.endswith('.ini')) or (not os.path.isfile(oldDepot)):
				logger.debug2(u"Ignoring '%s'" % (oldPath))
				continue
			try:
				depotId = forceHostId(depotId)
			except Exception as e:
				logger.error(u"Invalid depot: '%s': %s" % (oldPath, e))
				continue

			logger.notice(u"Updating depot '%s'" % depotId)

			oldDepotDict = {
				'id': depotId,
				'opsiHostKey': None,
				'depotLocalUrl': None,
				'depotRemoteUrl': None,
				'repositoryLocalUrl': None,
				'repositoryRemoteUrl': None,
				'description': None,
				'notes': None,
				'hardwareAddress': None,
				'ipAddress': None,
				'inventoryNumber': None,
				'networkAddress': None,
				'maxBandwidth': None,
				'isMasterDepot': True
			}

			if depotId in opsiHostKeys.keys():
				oldDepotDict['opsiHostKey'] = opsiHostKeys[depotId]

			updatedProductPropertyStates = []
			try:
				iniFile = IniFile(filename=oldDepot)
				ini = iniFile.parse()

				if ini.has_option('depotshare', 'localurl'):
					oldDepotDict['depotLocalUrl'] = ini.get('depotshare', 'localurl')
				if ini.has_option('depotshare', 'remoteurl'):
					oldDepotDict['depotRemoteUrl'] = ini.get('depotshare', 'remoteurl')
				if ini.has_option('repository', 'localurl'):
					oldDepotDict['repositoryLocalUrl'] = ini.get('repository', 'localurl').replace(u'/products', u'/repository')
				if ini.has_option('repository', 'remoteurl'):
					oldDepotDict['repositoryRemoteUrl'] = ini.get('repository', 'remoteurl').replace(u'/products', u'/repository')
				if ini.has_option('repository', 'maxbandwidth'):
					oldDepotDict['maxBandwidth'] = ini.get('repository', 'maxbandwidth')
				if ini.has_option('depotserver', 'description'):
					oldDepotDict['description'] = ini.get('depotserver', 'description')
				if ini.has_option('depotserver', 'notes'):
					oldDepotDict['notes'] = ini.get('depotserver', 'notes')
				if ini.has_option('depotserver', 'network'):
					oldDepotDict['networkAddress'] = ini.get('depotserver', 'network')
				if ini.has_option('depotserver', 'hardwareaddress'):
					oldDepotDict['hardwareAddress'] = ini.get('depotserver', 'hardwareaddress')
				if ini.has_option('depotserver', 'ipaddress'):
					oldDepotDict['ipAddress'] = ini.get('depotserver', 'ipaddress')
				if ini.has_option('depotserver', 'inventorynumber'):
					oldDepotDict['inventoryNumber'] = ini.get('depotserver', 'inventorynumber')

			except Exception as e:
				logger.warning(u"Could not get all information on depot: %s" % (e))

			backend.host_createObjects([OpsiDepotserver.fromHash(oldDepotDict)])

			logger.notice(u"Updating products on depot '%s'" % (depotId))
			productFilenames = []

			for productPath in (os.path.join(oldPath, u'products', u'localboot'), os.path.join(oldPath, u'products', u'netboot')):
				if not os.path.isdir(productPath):
					logger.warning(u"Path does not exist, skipping: '%s'" % (productPath))
					continue

				for productId in os.listdir(productPath):
					try:
						productFilename = os.path.join(productPath, forceProductId(productId))
						if not (os.path.isfile(productFilename)):
							logger.debug2(u"Ignoring '%s'" % (productFilename))
							continue
						productFilenames.append(productFilename)
					except Exception as e:
						logger.warning(u"Invalid product: '%s' in '%s': %s" % (productId, productPath, e))
						continue

			updatedProductDependencies = []
			for productFilename in productFilenames:
				packageControlFile = PackageControlFile(filename=productFilename)
				oldProduct = None

				try:
					oldProduct = packageControlFile.getProduct()
				except Exception as e:
					logger.error(u"Invalid product '%s': %s" % (productFilename, e))
					continue

				backend.product_createObjects([oldProduct])

				logger.info(u"Updating ProductProperties in '%s'" % (oldProduct.getId()))
				for pp in packageControlFile.getProductProperties():
					try:
						pp.setPropertyId(pp.getPropertyId().replace(u' ', u'_'))
						if pp.getPossibleValues():
							pp.setEditable(False)
						backend.productProperty_createObjects([pp])
					except Exception as e:
						logger.error(u"Could not create ProductProperty '%s': %s" % (pp.getIdent(), e))

					updatedProductPropertyStates.append(
						ProductPropertyState.fromHash(
							{
								'productId': pp.getProductId(),
								'propertyId': pp.getPropertyId().replace(u' ', u'_'),
								'objectId': depotId,
								'values': pp.getDefaultValues()
							}
						)
					)

				#logger.notice(u"Updating ProductDependencies in '%s'" % (depotId))
				#will be updated after all products
				#updatedProductDependencies = []
				for pd in packageControlFile.getProductDependencies():
					updatedProductDependencies.append(pd)

				logger.info(u"Updating ProductOnDepot on '%s'" % (depotId))

				locked = None
				if (len(lockedList) > 0):
					try:
						key = u'%s' % (oldProduct.getId().lower() + '#' + depotId.lower())
						locked = lockedList[key]
					except:
						pass

				backend.productOnDepot_createObjects([
						ProductOnDepot.fromHash({
							'productId': oldProduct.getId(),
							'productType': oldProduct.getType(),
							'productVersion': oldProduct.getProductVersion(),
							'packageVersion': oldProduct.getPackageVersion(),
							'depotId': depotId,
							'locked': locked
						})
				])

			logger.notice(u"Updating ProductDependencies on '%s'" % (depotId))
			for pd in updatedProductDependencies:
				try:
					backend.productDependency_createObjects([pd])
				except Exception as e:
					logger.error(u"Could not create ProductDependency '%s': %s" % (pd.getIdent(), e))

			logger.notice(u"Updating ProductPropertyStates in '%s'" % (depotId))
			for pps in updatedProductPropertyStates:
				try:
					backend.productPropertyState_createObjects([pps])
				except Exception as e:
					logger.error(u"Could not create ProductPropertyState '%s': %s" % (pps.getIdent(), e))
	else:
		logger.info(u"No depot folder, skipping depots.")

	logger.notice(u"Updating Configs ..." % ())
	try:
		iniFile = IniFile(filename=os.path.join(backupDir, u'global.ini'), ignoreCase=False)
		ini = iniFile.parse()

		for section in ini.sections():
			if section.lower() not in (u'networkconfig', u'generalconfig'):
				logger.warning(u"Unknown section in global.ini: %s" % (section))
				continue

			configId = None
			value = None

			for option in ini.options(section):
				configId = configId = option.lower()
				value = ini.get(section, option)

				multiValue = False
				try:
					if (section.lower() == u'networkconfig'):
						if (option.lower() == u'depotid'):
							configId = u'clientconfig.depot.id'
						elif (option.lower() == u'depotdrive'):
							configId = u'clientconfig.depot.drive'
						elif (option.lower() == u'nextbootserviceurl'):
							configId = u'clientconfig.configserver.url'
							if (value.find('/rpc') == -1):
								value = value + '/rpc'
							multiValue = True
						elif (option.lower() == u'windomain'):
							configId = u'clientconfig.windows.domain'
				except Exception as e:
					logger.error(u"Error in option '%s' in section '%s': '%s'" % (option, section, e))
					continue

				updatedConfigs.append(UnicodeConfig(id=configId, defaultValues=[value], multiValue=multiValue))
	except Exception as e:
		logger.error(u"Failed to update config '%s': '%s'" % (os.path.join(backupDir, u'global.ini'), e))

	for c in updatedConfigs:
		try:
			backend.config_createObjects([c])
		except Exception as e:
			logger.error(u"Could not create config '%s': %s" % (c.getIdent(), e))

	logger.notice(u"Updating clients ...")
	if not noClientDir:
		for filename in os.listdir(backupClientConfigDir):
			updatedConfigStates = []

			oldClient = os.path.join(backupClientConfigDir, filename)
			if not (filename.endswith('.ini')) or not os.path.isfile(oldClient):
				logger.debug2(u"Ignoring client ini '%s'" % (filename))
				continue
			try:
				clientId = forceHostId(filename[:-4].replace('_', '-'))
			except Exception as e:
				logger.error(u"Invalid client id '%s': %s" % (filename[:-4], e))
				continue

			logger.notice(u"Updating client '%s'" % clientId)

			oldClientDict = {
				'id': clientId,
				'opsiHostKey': None,
				'description': None,
				'notes': None,
				'hardwareAddress': None,
				'ipAddress': None,
				'inventoryNumber': None,
				'created': None,
				'lastSeen': None
			}

			if clientId in opsiHostKeys.keys():
				oldClientDict['opsiHostKey'] = opsiHostKeys[clientId]

			updatedProductPropertyStates = []
			updatedProductOnClients = []
			try:
				iniFile = IniFile(filename=oldClient)
				ini = iniFile.parse()

				if ini.has_option('info', 'description'):
					oldClientDict['description'] = ini.get('info', 'description')
				if ini.has_option('info', 'notes'):
					oldClientDict['notes'] = ini.get('info', 'notes')
				if ini.has_option('info', 'macaddress'):
					oldClientDict['hardwareAddress'] = ini.get('info', 'macaddress')
				if ini.has_option('info', 'ipaddress'):
					oldClientDict['ipAddress'] = ini.get('info', 'ipaddress')
				if ini.has_option('info', 'inventorynumber'):
					oldClientDict['inventoryNumber'] = ini.get('info', 'inventorynumber')
				if ini.has_option('info', 'created'):
					oldClientDict['created'] = ini.get('info', 'created')
				if ini.has_option('info', 'lastSeen'):
					oldClientDict['lastSeen'] = ini.get('info', 'lastSeen')

				for section in ini.sections():
					if (section.lower().endswith(u'-install')):
						for option in ini.options(section):
							try:
								updatedProductPropertyStates.append(
									ProductPropertyState.fromHash(
										{
										'productId':  section[:-8],
										'propertyId': option,
										'objectId':   clientId,
										'values':     [ini.get(section, option)]
										}
										)
									)
							except Exception as e:
								logger.error(u"Exception while creating ProductPropertyState from '%s': %s" % (section, e))

					elif (section.lower().endswith(u'_product_states')):
						for productId in ini.options(section):
							try:
								poc = {
									'productId': productId,
									'productType': section[:-15],
									'clientId': clientId,
									'installationStatus': u'not_installed',
									'actionRequest': u'none',
									'actionProgress': None,
									'targetConfiguration': None,
									'productVersion': None,
									'packageVersion': None,
									'modificationTime': None
								}

								try:
									(poc['installationStatus'], poc['actionRequest']) = ini.get(section, productId).split(u':')
								except Exception as e:
									logger.error(u"Failed to get state from '%s': %s" % (ini.get(section, productId), e))

								if poc['installationStatus'] not in (u'installed', u'not_installed'):
									poc['actionProgress'] = poc['installationStatus']
									poc['installationStatus'] = u'not_installed'

								if not poc['actionRequest'] in (u'setup', u'uninstall', u'update', u'always', u'once', u'custom', u'none'):
									poc['actionRequest'] = u'none'

								if (poc['installationStatus'] == 'not_installed') and (poc['actionRequest'] == 'none'):
									continue

								if ini.has_section(productId + u'-state'):
									if (ini.get(productId + u'-state', 'productversion') != u''):
										poc['productVersion']   = ini.get(productId + u'-state', 'productversion')
									if (ini.get(productId + u'-state', 'packageversion') != u''):
										poc['packageVersion']   = ini.get(productId + u'-state', 'packageversion')
									if ini.has_option(productId + u'-state', 'laststatechange'):
										poc['modificationTime'] = ini.get(productId + u'-state', 'laststatechange')

								updatedProductOnClients.append(ProductOnClient.fromHash(poc))
							except Exception as e:
								logger.error(u"Exception while creating ProductOnClient from '%s': %s" % (oldClient, e))
					elif (section.lower() in (u'networkconfig', u'generalconfig')):
						for option in ini.options(section):
							configId = configId = option.lower()
							value = ini.get(section, option)

							try:
								if (section.lower() == u'networkconfig'):
									if (option.lower() == u'depotid'):
										configId = u'clientconfig.depot.id'
									elif (option.lower() == u'depotdrive'):
										configId = u'clientconfig.depot.drive'
									elif (option.lower() == u'nextbootserviceurl'):
										configId = u'clientconfig.configserver.url'
										if (value.find('/rpc') == -1):
											value = value + '/rpc'
									elif (option.lower() == u'windomain'):
										configId = u'clientconfig.windows.domain'
							except Exception as e:
								logger.error(u"%s" % (e))
								continue

							updatedConfigStates.append(ConfigState(configId=configId, objectId=clientId, values=[value]))

			except Exception as e:
				logger.warning(u"Could not get all information on client: %s" % e)

			backend.host_createObjects([OpsiClient.fromHash(oldClientDict)])

			for cs in updatedConfigStates:
				#TODO: check, if configState.configId exists
				try:
					backend.configState_createObjects([cs])
				except Exception as e:
					logger.error(u"Could not create configState '%s': %s" % (cs.getIdent(), e))

			logger.info(u"Updating ProductOnClients in '%s'" % (clientId))
			for poc in updatedProductOnClients:
				try:
					backend.productOnClient_createObjects([poc])
				except Exception as e:
					logger.error(u"Could not create ProductOnClient '%s': %s" % (poc.getIdent(), e))


			logger.info(u"Updating ProductPropertyStates in '%s'" % (clientId))
			for pps in updatedProductPropertyStates:
				try:
					backend.productPropertyState_createObjects([pps])
				except Exception as e:
					logger.error(u"Could not create ProductPropertyState '%s': %s" % (pps.getIdent(), e))
	else:
		logger.error(u"No client folder, skipping clients.")

	logger.notice(u"Updating Groups ..." % ())
	updatedGroups = []
	updatedObjectToGroups = []
	backupClientGroupsFile = os.path.join(backupDir, u'clientgroups.ini')
	if os.path.isfile(backupClientGroupsFile):
		iniFile = IniFile(filename=backupClientGroupsFile)
		ini = iniFile.parse()

		parentGroupIdList= []
		for section in ini.sections():
			try:
				g = {
					'id': forceGroupId(section),
					'description': None,
					'notes': None,
					'parentGroupId': None
				}

				for option in ini.options(section):
					if (option.lower() == u'parentgroupid'):
						updatedGroup['parentGroupId'] = ini.get(section, option)
						if (not ini.get(section, option) in parentGroupIdList):
							parentGroupIdList.append(ini.get(section, option))
						continue

					if (ini.get(section, option) == 0):
						logger.debug2(u"Ignoring objectId '%s' in '%s' (value is 0)" % (option, section))
						continue

					otg = {
						'groupId' : section,
						'groupType' : 'HostGroup',
						'objectId' : forceObjectId(option)
					}

					updatedObjectToGroups.append(ObjectToGroup.fromHash(otg))

				updatedGroups.append(HostGroup.fromHash(g))
			except Exception as e:
				logger.error(u"Exception while creating Group from '%s': %s" % (section, e))

		#switching groups with parentGroupId after parentGroup
		switchedGroups = []
		unsortedGroups = updatedGroups
		counter = -1
		while (len(switchedGroups) != len(updatedGroups)):
			if (counter > 1000): #TODO: check for unresolved parentGroupIds
				logger.error(u"Unresolved parentGroupIdList: %s" % (parentGroupIdList))
				break
			else:
				counter =+ 1

			nowUnsorted = []
			for ug in unsortedGroups:
				if (ug.getParentGroupId() is None) or (not ug.getParentGroupId() in parentGroupIdList):
					switchedGroups.append(ug)
					if (ug.getId() in parentGroupIdList):
						parentGroupIdList.remove(ug.getId())
				else:
					nowUnsorted.append(ug)

			unsortedGroups = nowUnsorted

		updatedGroups = switchedGroups

		for g in updatedGroups:
			try:
				backend.group_createObjects([g])
			except Exception as e:
				logger.error(u"Could not create Group '%s': %s" % (g.getIdent(), e))

		for otg in updatedObjectToGroups:
			try:
				backend.objectToGroup_createObjects([otg])
			except Exception as e:
				logger.error(u"Could not create ObjectToGroup '%s': %s" % (otg.getIdent(), e))
	else:
		logger.error(u"No groups file, skipping groups.")

	#TODO: ignore?
	#AuditSoftwares/AuditSoftwareOnClients/AuditHardwares/AuditHardwareOnHosts


def configureMySQLBackend(unattendedConfiguration=None):
	def notifyFunction(message):
		logger.notice(message)
		messageBox.addText(u"{0}\n".format(message))

	def errorFunction(message):
		logger.error(message)
		ui.showError(
			text=message, width=70, height=6,
			title=u'Problem configuring MySQL backend'
		)

	dbAdminUser = u'root'
	dbAdminPass = u''
	config = backendUtils.getBackendConfiguration(u'/etc/opsi/backends/mysql.conf')
	messageBox = None

	if unattendedConfiguration is not None:
		errorTemplate = u"Missing '{key}' in unattended configuration."
		for key in ('dbAdminUser', 'dbAdminPass'):
			if key not in unattendedConfiguration:
				raise Exception(errorTemplate.format(key=key))

		dbAdminUser = unattendedConfiguration['dbAdminUser']
		dbAdminPass = unattendedConfiguration['dbAdminPass']
		# User / PW must not show in config file -> delete from config.
		for key in ('dbAdminUser', 'dbAdminPass'):
			del unattendedConfiguration[key]

		config.update(unattendedConfiguration)

		logger.debug(u"Configuration for unattended mysql configuration: {0}".format(config))
		configureMySQLBackendWithoutGUI(
			dbAdminUser, dbAdminPass, config, getSysConfig(),
			additionalBackendConfig=backendConfig,
		)
		return

	consoleLevel = logger.getConsoleLevel()
	logger.setConsoleLevel(LOG_NONE)
	ui = UIFactory(type='snack')
	try:
		while True:
			values = [
				{"name": u"Database host", "value": config['address']},
				{"name": u"Database admin user", "value": dbAdminUser},
				{"name": u"Database admin password", "value": dbAdminPass, "password": True},
				{"name": u"Opsi database name", "value": config['database']},
				{"name": u"Opsi database user", "value": config['username']},
				{"name": u"Opsi database password", "value": config['password'], "password": True}
			]
			values = ui.getValues(title=u'MysQL config', width=70, height=15, entries=values)
			if values is None:
				raise Exception(u"Canceled")

			config['address'] = values[0]["value"]
			dbAdminUser = values[1]["value"]
			dbAdminPass = values[2]["value"]
			config['database'] = values[3]["value"]
			config['username'] = values[4]["value"]
			config['password'] = values[5]["value"]

			messageBox = ui.createMessageBox(
				width=70, height=20, title=u'MysQL config', text=u''
			)

			try:
				configureMySQLBackendWithoutGUI(
					dbAdminUser, dbAdminPass,
					config, getSysConfig(),
					additionalBackendConfig=backendConfig,
					notificationFunction=notifyFunction,
					errorFunction=errorFunction
				)
				break
			except DatabaseConnectionFailedException:
				messageBox.hide()

		time.sleep(2)
		ui.showMessage(
			width=70, height=4,
			title=u'Success', text=u"MySQL Backend configuration done"
		)
	finally:
		if messageBox is not None:
			messageBox.hide()

		ui.exit()
		logger.setConsoleLevel(consoleLevel)


def registerDepot(unattendedConfiguration=None):
	"""
	Register a depot.

	The registration is done manually through a graphical commandline
	interface unless `unattendedConfiguration` supplies required data.

	For an unattended registration `unattendedConfiguration` should be
	of dict-type that must contain the following data:

		{
			"address": "fqdn.of.master",
			"username": "admin user for registration",
			"password": "the password of the user",
			"depot": {} //see below for config
		}


	An example configuration for `depot` can be:

		{
			"masterDepotId" : "id of master depot",
			"networkAddress" : "12.34.5.6/255.255.255.0",
			"description" : "Description of depot.",
			"inventoryNumber" : "inventory number",
			"ipAddress" : "12.34.5.6",
			"repositoryRemoteUrl" : "webdavs://depot.address:4447/repository",
			"depotLocalUrl" : "file:///var/lib/opsi/depot",
			"isMasterDepot" : true, // or false
			"notes" : "Put some notes here",
			"hardwareAddress" : "01:02:03:0a:0b:0c",
			"maxBandwidth" : 0,
			"repositoryLocalUrl" : "file:///var/lib/opsi/repository",
			"depotWebdavUrl" : "webdavs://depot.address:4447/depot",
			"depotRemoteUrl" : "smb://12.34.5.6/opsi_depot"
		}

	None of the entries in `depot` are mandatory.
	Machine-specific defaults will be used if no values are given.
	If a re-registration of a system is done the values of the existing
	depot will be used and any values given in `depot` will override
	the existing values.

	The `id` of the new depot will be the FQDN of the current system.
	"""
	backendConfigFile = u'/etc/opsi/backends/jsonrpc.conf'
	dispatchConfigFile = u'/etc/opsi/backendManager/dispatch.conf'

	getSysConfig()
	config = backendUtils.getBackendConfiguration(backendConfigFile)
	config.update(backendConfig)
	logger.info(u"Current jsonrpc backend config: %s" % config)

	if unattendedConfiguration:
		depotConfig = unattendedConfiguration.pop('depot', {})
		config.update(unattendedConfiguration)

		jsonrpcBackend = _getJSONRPCBackendFromConfig(unattendedConfiguration)
		depot = _getConfiguredDepot(jsonrpcBackend, depotConfig)
	else:
		jsonrpcBackend, depot = _getBackendConfigViaGUI(config)

	logger.notice(u"Creating depot '%s'" % depot.id)
	jsonrpcBackend.host_createObjects([depot])

	logger.notice(u"Getting depot '%s'" % depot.id)
	depots = jsonrpcBackend.host_getObjects(id=depot.id)
	if not depots:
		raise Exception(u"Failed to create depot")
	depot = depots[0]
	config['username'] = depot.id
	config['password'] = depot.opsiHostKey
	jsonrpcBackend.backend_exit()

	logger.notice(u"Testing connection to config server as user '%s'" % config['username'])
	try:
		jsonrpcBackend = JSONRPCBackend(address=config['address'], username=config['username'], password=config['password'])
	except Exception as e:
		raise Exception(u"Failed to connect to config server as user '%s': %s" % (config['username'], e))
	logger.notice(u"Successfully connected to config server as user '%s'" % config['username'])

	logger.debug("Updating config file {0}", backendConfigFile)
	backendUtils.updateConfigFile(backendConfigFile, config)

	logger.notice(u"Updating dispatch config '%s'" % dispatchConfigFile)

	# We want to keep lines that are currently commented out and only
	# replace the currently active backend configuration
	with codecs.open(dispatchConfigFile, 'r', 'utf-8') as originalDispatchConfig:
		lines = [
			line for line in originalDispatchConfig
			if line.strip().startswith((';', '#'))
		]

	with codecs.open(dispatchConfigFile, 'w', 'utf-8') as newDispatchConfig:
		newDispatchConfig.writelines(lines)
		newDispatchConfig.write("backend_.* : jsonrpc, opsipxeconfd, dhcpd\n")
		newDispatchConfig.write(".*         : jsonrpc\n")
	logger.notice(u"Dispatch config '%s' updated" % dispatchConfigFile)

	setRights()
	restartServices()


def _getJSONRPCBackendFromConfig(config):
	"""
	Connect to a depot using the given `config`.

	`config` must be a dict like the following:
		{
			"address": "fqdn.of.master",
			"username": "admin user for registration",
			"password": "the password of the user",
		}

	:type config: dict
	:raises OpsiAuthenticationError: If username / password is wrong.
	:raises Exception: If the supplied user is no opsi administrator.
	:return: A connected backend.
	:returntype: JSONRPCBackend
	"""
	connectionConfig = {
		"address": config['address'],
		"username": config['username'],
		"password": config['password']
	}
	logger.notice(u"Connecting to config server {address!r} as user {username!r}", **connectionConfig)
	jsonrpcBackend = JSONRPCBackend(**connectionConfig)
	if not jsonrpcBackend.accessControl_userIsAdmin():
		raise Exception(u"User {username!r} is not an admin user".format(**connectionConfig))

	logger.notice(u"Successfully connected to config server {address!r} as user {username!r}", **connectionConfig)
	return jsonrpcBackend


def _getConfiguredDepot(jsonrpcBackend, depotConfig=None):
	"""
	Get an configured depot.

	An example configuration for `depot` can be:
		{
			"masterDepotId" : "id of master depot",
			"networkAddress" : "12.34.5.6/255.255.255.0",
			"description" : "Description of depot.",
			"inventoryNumber" : "inventory number",
			"ipAddress" : "12.34.5.6",
			"repositoryRemoteUrl" : "webdavs://depot.address:4447/repository",
			"depotLocalUrl" : "file:///var/lib/opsi/depot",
			"isMasterDepot" : true, // or false
			"notes" : "Put some notes here",
			"hardwareAddress" : "01:02:03:0a:0b:0c",
			"maxBandwidth" : 0,
			"repositoryLocalUrl" : "file:///var/lib/opsi/repository",
			"depotWebdavUrl" : "webdavs://depot.address:4447/depot",
			"depotRemoteUrl" : "smb://depot.address/opsi_depot"
		}

	None of the entries are mandatory.
	We try to set sensible defaults

	The `id` of the new depot will be the FQDN of the current system.
	"""
	depotId = getSysConfig()['fqdn']
	depots = jsonrpcBackend.host_getObjects(id=depotId)
	try:
		depot = depots[0]
	except IndexError:  # no depot found
		depotLocalUrl = u'file:///var/lib/opsi/depot'
		depotRemoteUrl = u'smb://%s/opsi_depot' % getSysConfig()['hostname']
		depotWebdavUrl = u'webdavs://%s:4447/depot' % depotId
		hardwareAddress = getSysConfig()['hardwareAddress'] or u''
		repositoryRemoteUrl = u'webdavs://%s:4447/repository' % depotId

		depot = OpsiDepotserver(
			id=depotId,
			opsiHostKey=None,
			depotLocalUrl=depotLocalUrl,
			depotRemoteUrl=depotRemoteUrl,
			depotWebdavUrl=depotWebdavUrl,
			repositoryLocalUrl=u'file:///var/lib/opsi/repository',
			repositoryRemoteUrl=repositoryRemoteUrl,
			hardwareAddress=hardwareAddress,
			ipAddress=getSysConfig()['ipAddress'] or u'',
			networkAddress=u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask']),
			maxBandwidth=0,
			isMasterDepot=True,
			masterDepotId=None,
		)

	depotConfig = depotConfig or {}
	try:
		depot.setDescription(depotConfig['description'])
	except KeyError:
		logger.debug("Depot config holds no 'description'.")

	try:
		depot.setInventoryNumber(depotConfig['inventoryNumber'])
	except KeyError:
		logger.debug("Depot config holds no 'inventoryNumber'.")

	try:
		depot.setNotes(depotConfig["notes"])
	except KeyError:
		logger.debug("Depot config holds no 'notes'.")

	try:
		depot.setIpAddress(depotConfig["ipAddress"])
	except KeyError:
		logger.debug("Depot config holds no 'ipAddress'.")

	try:
		depot.setHardwareAddress(depotConfig["hardwareAddress"])
	except KeyError:
		logger.debug("Depot config holds no 'hardwareAddress'.")

	try:
		depot.setNetworkAddress(depotConfig['networkAddress'])
	except KeyError:
		logger.debug("Depot config holds no 'networkAddress'.")

	try:
		depot.setMaxBandwidth(forceInt(depotConfig['maxBandwidth']))
	except KeyError:
		logger.debug("Depot config holds no 'maxBandwidth'.")

	try:
		depot.setDepotLocalUrl(depotConfig["depotLocalUrl"])
	except KeyError:
		logger.debug("Depot config holds no 'depotLocalUrl'.")

	try:
		depot.setDepotRemoteUrl(depotConfig["depotRemoteUrl"])
	except KeyError:
		logger.debug("Depot config holds no 'depotRemoteUrl'.")

	try:
		depot.setDepotWebdavUrl(depotConfig["depotWebdavUrl"])
	except KeyError:
		logger.debug("Depot config holds no 'depotWebdavUrl'.")
		depot.depotWebdavUrl = None

	try:
		depot.setRepositoryLocalUrl(depotConfig["repositoryLocalUrl"])
	except KeyError:
		logger.debug("Depot config holds no 'repositoryLocalUrl'.")

	try:
		depot.setRepositoryRemoteUrl(depotConfig["repositoryRemoteUrl"])
	except KeyError:
		logger.debug("Depot config holds no 'repositoryRemoteUrl'.")

	try:
		depot.setIsMasterDepot(forceBool(depotConfig["isMasterDepot"]))
	except KeyError:
		logger.debug("Depot config holds no 'isMasterDepot'.")

	try:
		depot.setMasterDepotId(depotConfig["masterDepotId"])
	except KeyError:
		logger.debug("Depot config holds no 'masterDepotId'.")
		depot.masterDepotId = None

	if depot.maxBandwidth < 0:
		depot.maxBandwidth = 0

	return depot


def _getBackendConfigViaGUI(config):
	consoleLevel = logger.getConsoleLevel()
	logger.setConsoleLevel(LOG_NONE)

	ui = UIFactory(type='snack')
	try:
		adminUser = u'root'
		adminPass = u''
		messageBox = None
		while True:
			values = [
				{"name": u"Config server", "value": config['address']},
				{"name": u"Opsi admin user", "value": adminUser},
				{"name": u"Opsi admin password", "value": adminPass, "password": True}
			]
			values = ui.getValues(title=u'Config server connection', width=70, height=10, entries=values)
			if values is None:
				raise Exception(u"Canceled")

			config['address'] = values[0]["value"]
			adminUser = values[1]["value"]
			adminPass = values[2]["value"]

			messageBox = ui.createMessageBox(width=70, height=20, title=u'Register depot', text=u'')
			# Connect to config server
			logger.notice(u"Connecting to config server '%s' as user '%s'" % (config['address'], adminUser))
			messageBox.addText(u"Connecting to config server '%s' as user '%s'\n" % (config['address'], adminUser))

			try:
				jsonrpcBackend = _getJSONRPCBackendFromConfig({
					"address": config['address'],
					"username": adminUser,
					"password": adminPass
				})
			except Exception as e:
				messageBox.hide()
				logger.error(u"Failed to connect to config server '%s' as user '%s': %s" % (config['address'], adminUser, e))
				ui.showError(
					title=u'Failed to connect', width=70, height=6, seconds=0,
					text=u"Failed to connect to config server '%s' as user '%s': %s" % (config['address'], adminUser, e)
				)
				continue

			messageBox.addText(u"Successfully connected to config server '%s' as user '%s'\n" % (config['address'], adminUser))
			break

		depots = jsonrpcBackend.host_getObjects(id=getSysConfig()['fqdn'])
		if depots:
			# Already exists
			depot = depots[0]
			if not depot.depotWebdavUrl:
				depot.depotWebdavUrl = u''
			if not depot.masterDepotId:
				depot.masterDepotId = u''
			if not depot.hardwareAddress:
				depot.hardwareAddress = getSysConfig()['hardwareAddress'] or u''
			if not depot.ipAddress:
				depot.ipAddress = getSysConfig()['ipAddress'] or u''
			if not depot.networkAddress:
				depot.ipAddress = u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask'])
			if not depot.depotWebdavUrl:
				depot.depotWebdavUrl = u'webdavs://%s:4447/depot' % getSysConfig()['fqdn']
		else:
			depotLocalUrl = u'file:///var/lib/opsi/depot'
			depotRemoteUrl = u'smb://%s/opsi_depot' % getSysConfig()['hostname']

			depot = OpsiDepotserver(
					id=getSysConfig()['fqdn'],
					opsiHostKey=None,
					depotLocalUrl=depotLocalUrl,
					depotRemoteUrl=depotRemoteUrl,
					depotWebdavUrl=u'webdavs://%s:4447/depot' % getSysConfig()['fqdn'],
					repositoryLocalUrl=u'file:///var/lib/opsi/repository',
					repositoryRemoteUrl=u'webdavs://%s:4447/repository' % getSysConfig()['fqdn'],
					description=u'',
					notes=u'',
					hardwareAddress=getSysConfig()['hardwareAddress'] or u'',
					ipAddress=getSysConfig()['ipAddress'] or u'',
					inventoryNumber=u'',
					networkAddress=u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask']),
					maxBandwidth=0,
					isMasterDepot=True,
					masterDepotId=None,
			)

		while True:
			if depot.maxBandwidth < 0:
				depot.maxBandwidth = 0
			if depot.maxBandwidth > 0:
				depot.maxBandwidth = int(depot.maxBandwidth / 1000)

			values = [
				{"name": u"Description", "value": depot.description},
				{"name": u"Inventory number", "value": depot.inventoryNumber},
				{"name": u"Notes", "value": depot.notes},
				{"name": u"Ip address", "value": depot.ipAddress},
				{"name": u"Hardware address", "value": depot.hardwareAddress},
				{"name": u"Network address", "value": depot.networkAddress},
				{"name": u"Maximum bandwidth (kbyte/s)", "value": depot.maxBandwidth},
				{"name": u"Local depot url", "value": depot.depotLocalUrl},
				{"name": u"Remote depot url", "value": depot.depotRemoteUrl},
				{"name": u"Depot webdav url", "value": depot.depotWebdavUrl},
				{"name": u"Local repository url", "value": depot.repositoryLocalUrl},
				{"name": u"Remote repository url", "value": depot.repositoryRemoteUrl},
				{"name": u"Is master depot", "value": depot.isMasterDepot},
				{"name": u"Master depot id", "value": depot.masterDepotId or u''},

			]
			values = ui.getValues(title=u'Depot server settings', width=70, height=16, entries=values)
			if values is None:
				raise Exception(u"Canceled")

			error = None
			try:
				depot.setDescription(values[0].get('value'))
			except Exception as e:
				if not error:
					error = u'Invalid description'

			try:
				depot.setInventoryNumber(values[1].get('value'))
			except Exception as e:
				if not error:
					error = u'Inventory number invalid'

			try:
				depot.setNotes(values[2].get('value'))
			except Exception as e:
				if not error:
					error = u'Invalid notes'

			try:
				depot.setIpAddress(values[3].get('value'))
			except Exception as e:
				if not error:
					error = u'Invalid ip address'

			try:
				depot.setHardwareAddress(values[4].get('value'))
			except Exception as e:
				if not error:
					error = u'Invalid hardware address'

			try:
				depot.setNetworkAddress(values[5].get('value'))
			except Exception as e:
				if not error:
					error = u'Invalid network address'

			try:
				depot.setMaxBandwidth(forceInt(values[6].get('value')) * 1000)
			except Exception as e:
				if not error:
					error = u'Invalid maximum bandwidth'

			try:
				depot.setDepotLocalUrl(values[7].get('value'))
			except Exception as e:
				if not error:
					error = u'Depot local url invalid'

			try:
				depot.setDepotRemoteUrl(values[8].get('value'))
			except Exception as e:
				if not error:
					error = u'Depot remote url invalid'

			try:
				if values[9].get('value'):
					depot.setDepotWebdavUrl(values[9].get('value'))
				else:
					depot.depotWebdavUrl = None
			except Exception as e:
				if not error:
					error = u'Depot webdav url invalid'

			try:
				depot.setRepositoryLocalUrl(values[10].get('value'))
			except Exception as e:
				if not error:
					error = u'Repository local url invalid'

			try:
				depot.setRepositoryRemoteUrl(values[11].get('value'))
			except Exception as e:
				if not error:
					error = u'Repository remote url invalid'

			try:
				depot.setIsMasterDepot(values[12].get('value'))
			except Exception as e:
				if not error:
					error = u'Invalid value for is master depot'

			try:
				if values[13].get('value'):
					depot.setMasterDepotId(values[13].get('value'))
				else:
					depot.masterDepotId = None
			except Exception as e:
				if not error:
					error = u'Master depot id invalid'

			if error:
				ui.showError(title=u'Bad value', text=error, width=50, height=5)
				continue

			break
	finally:
		ui.exit()
		logger.setConsoleLevel(consoleLevel)

	return jsonrpcBackend, depot


def restartServices():
	""" Restart *opsiconfd* and *opsipxeconfd* """
	logger.notice(u"Restarting opsi webservice")
	execute("service opsiconfd restart")
	logger.notice(u"Restarting PXE service")
	execute("service opsipxeconfd restart")


def renewOpsiconfdCert(unattendedConfiguration=None):
	def makeCert():
		if certificateExisted:
			renewCertificate(
				yearsUntilExpiration=certparams['expires'],
				config=certparams
			)
		else:
			createCertificate(config=certparams)

	try:
		which("ucr")
		logger.notice(u"Don't use recreate method on UCS-Systems")
		return
	except Exception:
		pass

	certificateExisted = True
	try:
		certparams = loadConfigurationFromCertificate()
	except UnreadableCertificateError as err:
		logger.notice(
			u'Using default values because reading old certificate '
			u'failed: {0}'.format(err)
		)
		certparams = DEFAULT_CERTIFICATE_PARAMETERS
		certparams["commonName"] = forceHostId(getfqdn(conf=OPSI_GLOBAL_CONF))
	except NoCertificateError:
		certificateExisted = False
		certparams = DEFAULT_CERTIFICATE_PARAMETERS
		certparams["commonName"] = forceHostId(getfqdn(conf=OPSI_GLOBAL_CONF))

	if 'expires' not in certparams:
		certparams['expires'] = "2"  # Not included in existing cert

	if unattendedConfiguration is not None:
		logger.debug(u"Unattended certificate config: {0}".format(unattendedConfiguration))
		certparams.update(unattendedConfiguration)
		logger.debug(u"Configuration for unattended certificate renewal: {0}".format(certparams))

		makeCert()
		setPasswdRights()
		setRights(OPSICONFD_CERTFILE)
		restartServices()
		return

	consoleLevel = logger.getConsoleLevel()
	logger.setConsoleLevel(LOG_NONE)
	ui = UIFactory(type='snack')

	try:
		while True:
			values = [
				{"name": u"Country", "value": certparams["country"] or ''},
				{"name": u"State", "value": certparams["state"] or ''},
				{"name": u"Locality", "value": certparams["locality"] or ''},
				{"name": u"Organization", "value": certparams["organization"] or ''},
				{"name": u"OrganizationUnit", "value": certparams["organizationalUnit"] or ''},
				{"name": u"Hostname", "value": certparams["commonName"] or ''},
				{"name": u"Emailaddress", "value": certparams["emailAddress"] or ''},
				{"name": u"Expires (Years)", "value": certparams["expires"] or ''},
			]
			values = ui.getValues(title=u'Renew opsiconfd Certificate', width=70, height=15, entries=values)

			if values is None:
				raise RuntimeError(u"Canceled")

			certparams["country"] = values[0]["value"]
			certparams["state"] = values[1]["value"]
			certparams["locality"] = values[2]["value"]
			certparams["organization"] = values[3]["value"]
			certparams["organizationalUnit"] = values[4]["value"]
			certparams["commonName"] = values[5]["value"]
			certparams["emailAddress"] = values[6]["value"]

			error = None

			if error is None:
				if not certparams["commonName"] == forceHostId(getfqdn(conf=OPSI_GLOBAL_CONF)):
					error = "Hostname must be the FQDN from Server"

			if error is None:
				try:
					certparams["expires"] = forceInt(values[7]["value"])
				except Exception:
					error = u'No valid years for expiredate given, must be an integer'

			if error:
				ui.showError(title=u'Bad value', text=error, width=50, height=5)
				continue

			break
	finally:
		ui.exit()
		logger.setConsoleLevel(consoleLevel)

	makeCert()
	setPasswdRights()
	setRights(OPSICONFD_CERTFILE)
	restartServices()


def setPasswdRights():
	""" Setting correct permissions on ``/etc/opsi/passwd`` """
	logger.notice(u"Setting rights")
	opsiconfdUid  = pwd.getpwnam(OPSICONFD_USER)[2]
	adminGroupGid = grp.getgrnam(ADMIN_GROUP)[2]
	os.chown(u'/etc/opsi/passwd', opsiconfdUid, adminGroupGid)
	os.chmod(u'/etc/opsi/passwd', 0660)


def initializeBackends():
	if not os.path.exists(u'/etc/opsi/passwd'):
		with codecs.open(u'/etc/opsi/passwd', 'w', 'utf-8'):
			pass
		setPasswdRights()

	from OPSI.Backend.BackendManager import BackendManager
	backend = BackendManager(
		dispatchConfigFile=u'/etc/opsi/backendManager/dispatch.conf',
		backendConfigDir=u'/etc/opsi/backends',
		extensionConfigDir=u'/etc/opsi/backendManager/extend.d',
		depotbackend=False
	)
	backend.backend_createBase()

	logger.notice(u"Try to find a Configserver.")
	configServer = backend.host_getObjects(type='OpsiConfigserver')
	if not configServer and not backend.host_getIdents(type='OpsiConfigserver', id=getSysConfig()['fqdn']):
		depot = backend.host_getObjects(type='OpsiDepotserver', id=getSysConfig()['fqdn'])
		if not depot:
			logger.notice(u"Creating config server '%s'" % getSysConfig()['fqdn'])
			depotLocalUrl = u'file:///var/lib/opsi/depot'
			depotRemoteUrl = u'smb://%s/opsi_depot' % getSysConfig()['hostname']

			backend.host_createOpsiConfigserver(
				id=getSysConfig()['fqdn'],
				opsiHostKey=None,
				depotLocalUrl=depotLocalUrl,
				depotRemoteUrl=depotRemoteUrl,
				depotWebdavUrl=u'webdavs://%s:4447/depot' % getSysConfig()['fqdn'],
				repositoryLocalUrl=u'file:///var/lib/opsi/repository',
				repositoryRemoteUrl=u'webdavs://%s:4447/repository' % getSysConfig()['fqdn'],
				description=None,
				notes=None,
				hardwareAddress=getSysConfig()['hardwareAddress'],
				ipAddress=getSysConfig()['ipAddress'],
				inventoryNumber=None,
				networkAddress=u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask']),
				maxBandwidth=0,
				isMasterDepot=True,
				masterDepotId=None,
			)
			configServer = backend.host_getObjects(type='OpsiConfigserver', id=getSysConfig()['fqdn'])
		else:
			logger.notice(u"Converting depot server '%s' to config server" % getSysConfig()['fqdn'])
			configServer = OpsiConfigserver.fromHash(depot[0].toHash())
			backend.host_createObjects(configServer)

			# list expected in further processing
			configServer = [configServer]
	else:
		depot = backend.host_getObjects(type='OpsiDepotserver', id=getSysConfig()['fqdn'])
		if not depot:
			logger.notice(u"Creating depot server '%s'" % getSysConfig()['fqdn'])
			depotLocalUrl = u'file:///var/lib/opsi/depot'
			depotRemoteUrl = u'smb://%s/opsi_depot' % getSysConfig()['hostname']

			depotServer = backend.host_createOpsiDepotserver(
				id=getSysConfig()['fqdn'],
				opsiHostKey=None,
				depotLocalUrl=depotLocalUrl,
				depotRemoteUrl=depotRemoteUrl,
				depotWebdavUrl=u'webdavs://%s:4447/depot' % getSysConfig()['fqdn'],
				repositoryLocalUrl=u'file:///var/lib/opsi/repository',
				repositoryRemoteUrl=u'webdavs://%s:4447/repository' % getSysConfig()['fqdn'],
				description=None,
				notes=None,
				hardwareAddress=getSysConfig()['hardwareAddress'],
				ipAddress=getSysConfig()['ipAddress'],
				inventoryNumber=None,
				networkAddress=u'%s/%s' % (getSysConfig()['subnet'], getSysConfig()['netmask']),
				maxBandwidth=0,
				isMasterDepot=True,
				masterDepotId=None,
			)

	if configServer:
		if configServer[0].id == getSysConfig()['fqdn']:
			configServer = backend.host_getObjects(type='OpsiConfigserver')
			if not configServer:
				raise Exception(u"Config server '%s' not found" % getSysConfig()['fqdn'])
			configServer = configServer[0]
			if getSysConfig()['ipAddress']:
				configServer.setIpAddress(getSysConfig()['ipAddress'])
			if getSysConfig()['hardwareAddress']:
				configServer.setHardwareAddress(getSysConfig()['hardwareAddress'])

			#make sure the config server is present in all backends or we get reference error later on
			backend.host_insertObject(configServer)

		# initializeConfigs does only handle a single object
		configServer = forceList(configServer)[0]

	initializeConfigs(backend=backend, configServer=configServer)
	backend.backend_exit()

	depotDir = '/var/lib/opsi/depot'
	if not os.path.exists(depotDir):
		try:
			os.mkdir(depotDir)
			if os.path.exists("/opt/pcbin/install"):
				logger.warning(u"You have an old depot configuration. Using /opt/pcbin/install is depracted, please use /var/lib/opsi/depot instead.")
		except Exception as error:
			logger.warning(u"Failed to create depot directory '%s': %s" % (depotDir, error))


def editConfigDefaults():
	from OPSI.Backend.BackendManager import BackendManager
	backend = BackendManager(
		dispatchConfigFile=u'/etc/opsi/backendManager/dispatch.conf',
		backendConfigDir=u'/etc/opsi/backends',
		extensionConfigDir=u'/etc/opsi/backendManager/extend.d',
		depotbackend=False
	)
	configs = backend.config_getObjects()

	consoleLevel = logger.getConsoleLevel()
	logger.setConsoleLevel(LOG_NONE)
	ui = UIFactory(type='snack')
	try:
		while True:
			entries = []
			maxConfigIdLen = 0
			for config in configs:
				if u'configed.saved_search.' in config.id:
					continue

				if (len(config.id) > maxConfigIdLen):
					maxConfigIdLen = len(config.id)
			format = u"%-10s %-" + str(maxConfigIdLen) + "s = %s"
			for config in configs:
				type = '[unicode]'
				if (config.getType() == 'BoolConfig'):
					type = '[bool]'

				if u'configed.saved_search.' in config.id:
					continue

				values = u', '.join(forceUnicodeList(config.defaultValues))
				if len(values) > 60:
					values = values[:60] + '...'
				entries.append(
					{
						"id": config.id,
						"name": format % (type, config.id, values)
					}
				)

			selection = ui.getSelection(
				entries, radio=True,
				width=100, height=10,
				title=u'Please select config value to change',
				okLabel='Change', cancelLabel='Quit'
			)

			if not selection:
				return

			configId = None
			for entry in entries:
				if (selection[0] == entry['name']):
					configId = entry['id']
					break

			selectedConfig = -1
			for i in range(len(configs)):
				if (configs[i].id == configId):
					selectedConfig = i
					break

			addNewValue = False
			cancelLabel = u'Back'
			title = u'Edit default values for: %s' % configs[selectedConfig].id
			text = configs[selectedConfig].description or u''
			if configs[selectedConfig].possibleValues:
				entries = []
				for possibleValue in configs[selectedConfig].possibleValues:
					entries.append({'name': possibleValue, 'value': possibleValue, 'selected': possibleValue in configs[selectedConfig].defaultValues})
				radio = not configs[selectedConfig].multiValue
				if configs[selectedConfig].editable:
					entries.append({'name': '<other value>', 'value': '<other value>', 'selected': False})
				selection = ui.getSelection(entries, radio=radio, width=65, height=10, title=title, text=text, cancelLabel=cancelLabel)

				if selection is None:
					continue
				if "<other value>" in selection:
					addNewValue = True
				else:
					configs[selectedConfig].setDefaultValues(selection)
			else:
				addNewValue = True

			if addNewValue:
				default = u''
				if configs[selectedConfig].defaultValues:
					default = configs[selectedConfig].defaultValues[0]
				value = ui.getValue(width=65, height=13, title=title, default=default, password=False, text=text, cancelLabel=cancelLabel)
				if value is None:
					continue

				possibleValues = configs[selectedConfig].getPossibleValues()
				if value not in possibleValues:
					possibleValues.append(value)
					configs[selectedConfig].setPossibleValues(possibleValues)
				configs[selectedConfig].setDefaultValues(value)

			backend.config_updateObjects([configs[selectedConfig]])

	finally:
		ui.exit()
		logger.setConsoleLevel(consoleLevel)


def usage():
	print u"\nUsage: %s [options]" % os.path.basename(sys.argv[0])
	print u""
	print u"Options:"
	print u"   -h, --help  show this help"
	print u"   -l          log-level 0..9"
	print u""
	print u"   --log-file <path>             path to log file"
	print u"   --backend-config <json hash>  overwrite backend config hash values"
	print u"   --ip-address <ip>             force to this ip address (do not lookup by name)"
	print u"   --register-depot              register depot at config server"
	print u"   --set-rights [path]           set default rights on opsi files (in [path] only)"
	print u"   --init-current-config         init current backend configuration"
	print u"   --update-from=<version>       update from opsi version <version>"
	print u"   --update-mysql                update mysql backend"
	print u"   --update-file                 update file backend"
	print u"   --configure-mysql             configure mysql backend"
	print u"   --edit-config-defaults        edit global config defaults"
	print u"   --cleanup-backend             cleanup backend"
	print u"   --auto-configure-samba        patch smb.conf"
	print u"   --auto-configure-dhcpd        patch dhcpd.conf"
	print u"   --renew-opsiconfd-cert        renew opsiconfd-cert"
	print u"   --patch-sudoers-file	         patching sudoers file for tasks in opsiadmin context."
	print u""


def main():
	if (os.geteuid() != 0):
		raise Exception(u"This script must be startet as root")

	try:
		(opts, args) = getopt.getopt(sys.argv[1:], "hl:",
			[
				'help', 'log-file=', 'ip-address=', 'backend-config=',
				'init-current-config', 'set-rights', 'auto-configure-samba',
				'auto-configure-dhcpd', 'register-depot', 'configure-mysql',
				'update-mysql', 'update-file', 'edit-config-defaults',
				'cleanup-backend', 'update-from=', 'renew-opsiconfd-cert',
				'patch-sudoers-file', 'unattended='
			]
		)

	except Exception:
		usage()
		raise

	task = None
	updateFrom = None
	autoConfigureSamba = False
	autoConfigureDhcpd = False
	global backendConfig
	backendConfig = {}
	unattended = None

	for (opt, arg) in opts:
		if opt in ("-h", "--help"):
			usage()
			return
		elif (opt == "--log-file"):
			logger.setLogFile(arg)
			logger.setFileLevel(LOG_DEBUG)
		elif (opt == "-l"):
			logger.setConsoleLevel(int(arg))
		elif (opt == "--ip-address"):
			global ipAddress
			ipAddress = forceIpAddress(arg)
		elif (opt == "--backend-config"):
			backendConfig = json.loads(arg)
		elif (opt == "--init-current-config"):
			task = 'init-current-config'
		elif (opt == "--set-rights"):
			task = 'set-rights'
		elif (opt == "--register-depot"):
			task = 'register-depot'
		elif (opt == "--configure-mysql"):
			task = 'configure-mysql'
		elif (opt == "--update-mysql"):
			task = 'update-mysql'
		elif (opt == "--update-file"):
			task = 'update-file'
		elif (opt == "--edit-config-defaults"):
			task = 'edit-config-defaults'
		elif (opt == "--cleanup-backend"):
			task = 'cleanup-backend'
		elif (opt == "--update-from"):
			updateFrom = arg
		elif (opt == "--auto-configure-samba"):
			autoConfigureSamba = True
		elif (opt == "--auto-configure-dhcpd"):
			autoConfigureDhcpd = True
		elif (opt == "--renew-opsiconfd-cert"):
			task = "renew-opsiconfd-cert"
		elif (opt == "--patch-sudoers-file"):
			task = "patch-sudoers-file"
		elif opt == '--unattended':
			logger.debug(u'Got unattended argument: {0}'.format(arg))

			if args and not arg.strip().endswith('}'):
				logger.debug("Probably wrong reading of arguments by getopt.")

				tempArgs = [arg]
				while args and not tempArgs[-1].strip().endswith('}'):
					tempArgs.append(args.pop(0))
					logger.debug("temp arguments are: {0}".format(tempArgs))

				arg = ' '.join(tempArgs)
				del tempArgs

			unattended = json.loads(arg)

	path = u'/'
	if len(args) > 0:
		logger.debug("Additional arguments are: {0}".format(args))
		if task == 'set-rights' and len(args) == 1:
			path = os.path.abspath(forceFilename(args[0]))
		else:
			usage()
			raise Exception(u"Too many arguments")

	if autoConfigureSamba:
		configureSamba()

	if autoConfigureDhcpd:
		configureDHCPD()

	if (task == 'set-rights'):
		setRights(path)

	elif (task == 'init-current-config'):
		initializeBackends()
		configureClientUser()

	elif task == 'configure-mysql':
		configureMySQLBackend(unattended)

	elif (task == 'update-mysql'):
		updateMySQLBackend(additionalBackendConfiguration=backendConfig)
		update()

	elif (task == 'update-file'):
		updateFileBackend()
		update()

	elif (task == 'register-depot'):
		registerDepot(unattended)
		configureClientUser()

	elif (task == 'edit-config-defaults'):
		editConfigDefaults()

	elif (task == 'cleanup-backend'):
		cleanupBackend()

	elif (task == "renew-opsiconfd-cert"):
		renewOpsiconfdCert(unattended)

	elif (task == "patch-sudoers-file"):
		patchSudoersFileForOpsi()

	elif (updateFrom):
		update(updateFrom)

	elif not autoConfigureSamba and not autoConfigureDhcpd:
		usage()
		sys.exit(1)


if (__name__ == "__main__"):
	logger.setLogFormat(u'[%l] [%D] %M (%F|%N)')
	logger.setLogFile(LOG_FILE)
	logger.setFileLevel(LOG_INFO)
	exception = None
	try:
		main()
	except SystemExit:
		pass
	except Exception as exception:
		logger.logException(exception)
		print >> sys.stderr, u"\nERROR: %s\n" % exception
		sys.exit(1)

	sys.exit(0)
